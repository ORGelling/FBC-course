Exercise 56: 

Write a program that can output the process accounting log in readable form,
either in full or just what wasn't exited properly

We do exactly this, adding some notes about what is going on: 

We found that our command names are 16 bits from the ACCT_COMM definition
inside the acct.h header. As such process names longer than that are simply
truncated. Since it is thus already defined inside our program we use it to
read the max length, and then also cut off any possible trailing nulls to keep
things nice and tidy.

After some researching (and a bit of arguing with copilot, which we don't
actually trust that well on matters like these) we noticed that the signal 
codes from signum.h shown in the exercise go up to 31, and we can have our
computer show us the rest by running:
kill -l, which gives me:

 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	
42) SIGRTMIN+8  43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	
46) SIGRTMIN+12	47) SIGRTMIN+13 48) SIGRTMIN+14	49) SIGRTMIN+15	
50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12 53) SIGRTMAX-11	
54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7 58) SIGRTMAX-6
59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2 63) SIGRTMAX-1
64) SIGRTMAX

A bunch of the error signals shown in the exercise's example go way higher 
than that. Copilot might be onto something when it tells us that the 
ac_exitcode member of the acct_v3 struct stores both a SIG type kill code, 
and an exit code that simply  represents how the program ended. If the first 
8 bits are stripped off of the ac_exitcode member and used as our d_signal to
then run the program we get a nice set of programs that actually ended in a 
faulty way, testig this by manually killing and terminating processes inside 
a terminal, like:

sleep 1000 &
and then executing 
kill <PID>
where PID is the process id that shows up after running the sleep command. We
can add a -9 or -15 after kill as well to specify SIGKILL or SIGTERM. We then
indeed see:
'sleep' KILL
'sleep' TERM

We made the program print debug info, like the (interpreted) value of
ac_exitcode, and it seems to align with clipping the first 8 bits off for the
signal, and the next 8 for possible exitcodes if a process was not killed by 
SIG. We have decided, however, to stick with the exercise's convention, and 
only use the ac_exitcode member in full, as the exercise shows codes that do 
not simply fit into 8 bits. We thus comment out the second int datamember and
any lines that are used for debugging and filtering/showing the exitcode and
signal separately. Learning about this process and the data structure was 
rather interesting!

We do run into an issue that shows we might be doing something wrong: when a
program terminates due to a segfault we should see an exitcode 11, for 
SIGSEGV, yet when we purposely make a program segfault our stored error code 
is 139, with a hex value: 8b. This does not seem to align properly with the 
SIGnals and exitcode, and instead seems to represent the shell's exit status
is 139, which we can see by executing
echo $?
right after the segfaulting program runs. Apparently in this case the process
accounting is storing the shell's exit status rather than the segfault code?
We aren't entirely sure why this is.
