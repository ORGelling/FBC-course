Exercise 21: Make a quicksort function

We have ended up making a quicksort function that uses Hoare's partition
scheme. This function partitions an array of strings into two parts and
compares all the strings of each array part with the leftmost member of that
array. Anything that should be alphabetically aligned left of it will be
swapped. It recursively calls itself over and over on the array parts left and
right of this pivot until only very small array sections are left and 
everything is sorted nicely. 

We grab the environ array as extern char, but note that it could also, in some
implementations, be taken as the 3rd int main() argument. Since we are not
sure if this compiles correctly elsewhere we choose the safer option.

Our program finds the array size of our environ array by looping until it
finds a null pointer, but it could also be done using sizeof(the array) /
sizeof(array alement type).

We note that we treat the environ array as an array of pointers to chars, and
that our qs function(s) complement that. We have not cast the elements to
strings and as such this function will not work if an array of std::string
objects is passed to it. We considered the terminology of the question and the
fact we have to operate on the environ character pointer array to imply that
we could operate on these C-strings as is. Else we could have the size counter
also copy all the elements into a new std::string array and hand that to our
qs function. That would require some reworking of the subfunctions though.

As in other exercises this week, we have elected to leave const size_t's as
is, and to not make them references, as doing so would not save memory or
computation time, and leaves the intent of the code a bit clearer.
