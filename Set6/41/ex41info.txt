Exercise 41: 

Adapt exercise 35 of the previous set to work with raw memory and a doubling
capacity whenever all raw memory is used up.

We do exactly what the exercise asks. Of note is our way of writing the insert
function. Here we decide to move the Char objects at and beyond the position
where a new Char should be inserted one step upwards. We do this by first
initialising a new Char object just beyond the existing array, and then
copying all the values from the Chars before it into their new correct spot. 
It would be possible and (likely) not entirely incorrect to clean up the 
memory of each place and reconstruct the Char objects that have to move, but
instead we decided to simply initialise the new location and then move the
values of all the Char objects before it. This seems the more efficient way to
deal with the simple Char structs we are using. 

We ran our program through valgrind's memory leak check with the following
command:

valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes 
--verbose --log-file=valgrind-out.txt

and it told us that we do not have a memory leak! Yay!
