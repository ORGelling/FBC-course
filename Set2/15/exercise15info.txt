Exercise 15: Applying standard types in non-standard ways

We must write a program that shows all possible combinations of input 
arguments. To do this we make use of the bit structure of an iterating int.

If we look at our input arguments and the structure of the output, we will 
see quickly that it looks similar to the bits of a binary number. Using 1s to
show the array value, and 0s to hide it. If we iterate through a number and
show its bits we see (only showing the last 4 bits):
0: 000
1: 001
2: 010
3: 011
4: 100
5: 101
and so on. This is exactly how we want to show the argv[] array's contents! 
As such we will write a program with two nested for loops, one to iterate 
through our binary output show/hide selector, and one to loop through the 
input arguments and add them to the output stream.

Thus takes shape our source file. First we take argv, increment it once 
(to skip the program name), and store it in a pointer (array) to a const 
pointer to const characters. This way we ensure constance and minimal 
evaluations. We note that this, among with dereferencing the pointer later on
in the "print loop" might not exactly be part of the material, but we also 
saw this used in exercise 16's example, and have had pointers mentioned and
covered in the lecture this week.

We then declare two constant size_t's to store our input argument count 
(--argc, since we don't count the program name), and our total of different 
combination permutations (2 to the power of our input argument count, which 
we compute simply by using 1 << count). We define specific variables and make
them const to avoid unnecessary repeated evaluations here. We also increment
argv to skip outputting the program title.

Now come the nested for loops. First we have the outer one, which defines the
different lines, or permutations of the iteration, and then the inner one, 
which checks the arguments for printing and does so if they need to be. To do
this we use a bitmask with a single 1 and shift it left as we move up the 
arguments, comparing them to the bit value of the current line's permutation
representation. On line 1 (bit combination 0000) we show no arguments, on 
line 2 we only show the first (0001), on line 5 we show the first and third 
(0101), etc. Our bitmask will return 1 if the bits of the line/selection 
index are 1 there, and 0 if not. Thus this is the condition we use to check 
whether this current argument must be printed, and do so by dereferencing the
incremented pointer "args". We loop over all the arguments each line, output
a newline character, and then repeat this process until we are through all of
the permutations. 

We note of course that our argSet, the bit-representation of the current 
permutation, is offset by 1 in our line number, as we want to have the first
line have number 1, even though it shows the combination 0000!
