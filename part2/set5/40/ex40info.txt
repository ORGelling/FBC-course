Exercise 40: Define a class with its data being elsewhere

We use a helper function only visible to the internal header and member
functions that returns an unordered_map containing the the object addresses as
keys and pairs of size_t's and vector<string>s as values, representing the
index of the object and the actual contents it holds.

We considered using a vector of tuples or structs, but with the unordered_map
we can use the address of the current object (this) as the key to easily find
our object with get(), and to make removing the right object inside the 
destructor incredibly simple. This does mean we need to search through the 
whole map when calling get(size_t idx), but all in all we consider this a very
effective approach. It seemed like storing the object addresses was the only 
consistent way of keeping track of which data belongs to which object, so 
having an unordered_map that then connects to the object index and its actual
data seemed like the only way to avoid issues with using the vector index as 
object number (if Lines 2 goes out of scope then a possible Lines3 is now at 
the index that Lines 2 had). 

We add the the data used and the output of our test run that was redirected 
into return.txt, to show how our program works. We added some extra checks
and accessed the data in the objects beyond the first one through their 
direct get() functions without the index, as it seems strange the main 
function given by the exercise does not attempt this. 

We hope our answer to this exercise is not overengineered, and instead a
nice, albeit slightly elaborate, approach to this quandry. There seemed to be
a lot of pitfalls arising from whichever choice of data structure, wanting to
keep things simple but also efficient. The struct of all three "data members"
was likely the most clear and easy-to-read option, but using the object
addresses as key felt rather elegant.
