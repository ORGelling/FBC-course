//JB: 1
Exercise 18: Inheriting constructor functionality

We make a simple Base and Derived classes as specified, and run the main1.cc
script. It has references for use of Base's ctors directly, and calls
Derived's constructors as well. Our output gives us this:

$ tmp/bin/binary 
Calling Base default ctor
Calling Base copy ctor
Calling Base move ctor

Calling Base default ctor
Calling Base default ctor
Calling Base default ctor

Calling Base dtor
Calling Base dtor
Calling Base dtor
Calling Base dtor
Calling Base dtor
Calling Base dtor

We see that empty constructors will simply call Base's default ctor. We
learned in the lecture that when explicitly defining constructors the default
constructor of the base class is always used. We can either call the copy and
move ctors explicitly, or we can let the compiler build our copy and move 
constructors for us, in which case it will pick the correct ones
automatically! We see this confirmed:

$ tmp/bin/binary 
Calling Base default ctor
Calling Base copy ctor
Calling Base move ctor

Calling Base default ctor
Calling Base copy ctor
Calling Base move ctor

Calling Base dtor
Calling Base dtor
Calling Base dtor
Calling Base dtor
Calling Base dtor
Calling Base dtor

To ensure that Derived mixes up Base's copy and move ctors, we have to
explicitly call them inside Derived's member initialiser list while also
explicitly changing the const-ness when needed:

$ tmp/bin/binary 
Calling Base default ctor
Calling Base copy ctor
Calling Base move ctor

Calling Base default ctor
Calling Base move ctor
Derived copy calling move
Calling Base copy ctor
Derived move calling copy

Calling Base dtor
Calling Base dtor
Calling Base dtor
Calling Base dtor
Calling Base dtor
Calling Base dtor
