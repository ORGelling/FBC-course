//JB: ?
Exercise 22: Learn about base class references.

We can call Derived::hello() from Base &obj using a static_cast<Derived>() or
static_cast<Derived &>(). This is bad practice since promoting an object like
this can lead to undefined behaviour when the missing data that Derived might
add around Base is needed. static_cast<>() does not verify whether the
conversion is safe or whether anything will go wrong when using Derived's
functions on the casted object.
JB: Yes.
//JB: The static_cast<Derived> would not be all that bad, as it would
//JB:  construct a proper Derived object parameter from the Base object
//JB: argument.
//JB: (All under the assumption that the promotion is allowed and the
//JB: constructor is sound.)

Another way to do this is by implementing an assignment operator that allows
us to bind a Base object to a Derived object and thus calling hello() on that
will call Derived::hello(). The same danger can appear here if the assignment
operator is not implemented safely. Slicing is hard to avoid in this case too.
This approach however is likely safer depending on if the programmer
implements the assignment operator well. (We did not!)
//JB: Not sure what it means to 'bind' a Base to a Derived. References bind.
//JB: Assignment operators assign.
//JB: I agree that your assignment operator is the granddaddy of all slices
//JB: and as such utterly unsafe.
//JB: But slicing is not the same problem as checkless downcasting, and by
//JB: implementing this operator, you made the class explicitly suggest
//JB: it can handle the very problem it is now causing.

// JB: (Gave '?' to ensure you understand slicing != downcasting though
// JB: they are related.)
