Exercise 16: (left this as-is)

Write a program that can output the reverse of a line of UTF-8 characters.

We use the fact that UTF-8 characters that consist of multiple bytes have a 1
on the MSB of each byte, but a 0 on the one to the right, except for the 
leftmost byte, which has as many 1s as there are bytes read for this 
character. More significantly though, it means it starts with two 1's, rather
than a 1 and a 0, which we can use to detect the rightmost byte.

The code starts with a while loop in case we want to send through a file that
has multiple lines, rather than just one from input. This can be done away 
with and replaced simply by the getline inside the while condition. 

We have two nested while loops. One that runs over all the characters in the
line, and one that checks if the character uses more than one byte to be
represented. We use an anonymous namespace to store the masks we need to
check if the MSB is 1 but the one to the right of that is 0, in which case we
are looking at a byte that does not represent a character on its own. If MSB
and the next one are both 1 we have reached the final byte of this character,
and break this while. We then output a substring of our line of the length of
bytes counted.

Thus we have it. We do note that there is some finnicky behaviour with 
newline characters, as executing cat utf-8-input.txt shows a newline at the 
end of this file, but that is cut off by our getline function. We assume this
behaviour is fine, and output a newline character at the end of our outermost
for loop. If we pipe the input file through our program twice and write it to
an output file we get the exact same now!
