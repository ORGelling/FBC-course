Exercise 25:

Describe what encapsulation and data hiding means, and why they are impotant
for classes. Give a small example. 

Encapsulation and data hiding are both related to closing the class's
"privates" off from the "outer world". Data hiding is the practice of making
data members "private" within the class interface, such that they cannot be
reached by the outside. You should not just go rummaging through someone's (or
something's) "privates" after all! To enforce the privacy of the data members,
all the modification that is performed on said data can only be done by member
functions. We call this practice "encapsulation", and it keeps parts of the 
program that shouldn't be interacting with or manipulating each other from 
doing so. It keeps the data safe and unmeddled, and cordons off the
responsibility for its integrity such that errors and issues don't pop up
easily, and are relatively easy to address since one knows which part of the
program is responsible for interacting with these data members.

We only need to give the interface as that is all you need to understand how a
class works and can be interacted with. The inner mechanics are not needed for
this.

Since I am a physicist, allow me to make a class interface of the
fundamental forces of our universe:

#ifndef FUNDAMENTAL_FORCES_H
#define FUNDAMENTAL_FORCES_H

Class Particle
{
    // data members: (private)
    double  const       d_mass;
    double              d_relativistic_mass;
    float   const       d_spin;
    float               d_angular_momentum;
    size_t  const       d_charge;
    unsigned long long  d_momentum;
    
    unsigned long long  d_energy;
    
    double  const       d_weak_coupling;
    double  const       d_strong_coupling;
    double  const       d_electromagnetic_coupling;
    double  const       d_gravity_coupling;
    
    public:             // member functions
        Particle();
        Particle
        (
            double              mass, 
            float               spin, 
            size_t              charge,
            unsigned long long  momentum
        );
        ~Particle(Particle antiparticle);
        
        Particle *fusion(Particle target);
        Particle *fission();
        Particle *fission(Particle target);
        
        void accelerate();
        void collide(Particle target);
        
        double calculateWeakForce(Particle &source);
        double calculateStrongForce(Particle &source);
        double calculateElectroMagneticForce(Particle &source);
        double calculateGravitationalForce(Particle &source);

        long long &momentum();
        long long &energy();
        long long &relativisticMass();
        float angularMomentum();
};

#endif

Behold, our universe (approximately). We see among the data members all the
aspects that define a particle, and all the couplings with the four
fundamental forces. These can be set to auto initialise to a very basic
particle type, like a proton, or can be chosen to represent something more
unique. They are not settable or changeable, as particles don't generally
change these aspects. We can however, define more exotic particles too. 

With them we can then model a bunch of interactions, we can accelerate,
collide, fuse and split them (the latter can happen spontaneously or after a
collision). Fusing or splitting particles doesn't always lead to only one resp
particle, hence the pointer (array). Destroying particles only happens in 
pairs. We may have gone slighty overboard on the "keep it small/simple" aspect
but we hope this helps illustrate our understanding of classes in a fun way.
