Exercise 25:

Describe what encapsulation and data hiding means, and why they are impotant
for classes. Give a small example. 

Encapsulation and data hiding are both related to closing the class's
"privates" off from the "outer world". Data hiding is the practice of making
data members "private" within the class interface, such that they cannot be
reached by the outside. You should not just go rummaging through someone's (or
something's) "privates" after all! To enforce the privacy of the data members,
all the modification that is performed on said data can only be done by member
functions. We call this practice "encapsulation", and it keeps parts of the 
program that shouldn't be interacting with or manipulating each other from 
doing so. It keeps the data safe and unmeddled, and cordons off the
responsibility for its integrity such that errors and issues don't pop up
easily, and are relatively easy to address since one knows which part of the
program is responsible for interacting with these data members.

We only need to give the interface as that is all you need to understand how a
class works and can be interacted with. The inner mechanics are not needed for
this.

Since I am a physicist, allow me to make a class interface for a class that
represents the particle-nature of our universe:

#ifndef PARTICLE_HEADER_H
#define PARTICLE_HEADER_H

Class Particle
{
    // data members: (private)
    double  const       d_mass;
    double              d_relativistic_mass;
    float   const       d_spin;
    float               d_angular_momentum;
    size_t  const       d_charge;
    unsigned long long  d_momentum;
    
    unsigned long long  d_energy;
    
    double  const       d_weak_coupling;
    double  const       d_strong_coupling;
    double  const       d_electromagnetic_coupling;
    double  const       d_gravity_coupling;
    
    public:             // member functions
        Particle() = default;
        Particle
        (
            double const             mass, 
            float  const             spin, 
            size_t const             charge,
            unsigned long long const momentum,
        );
        ~Particle(Particle antiparticle);
        
        Particle *fusion(Particle &&target);
        Particle *fission();
        Particle *fission(Particle &&target);
        
        void accelerate();
        void collide(Particle &target);
        
        double calculateWeakForce(Particle &source) const;
        double calculateStrongForce(Particle &source) const;
        double calculateElectroMagneticForce(Particle &source) const;
        double calculateGravitationalForce(Particle &source) const;

        long long &momentum() const;
        long long &energy() const;
        long long &relativisticMass() const;
        float angularMomentum() const;
};

#endif

Behold, our universe (approximately). We see among the data members all the
aspects that define a particle, and all the couplings with the four
fundamental forces. These can be set to auto initialise to a very basic
particle type, like a proton. They are not settable or changeable, as 
particles don't generally change these aspects. We can however, define more 
exotic particles too. 

With them we can then model a bunch of interactions, we can accelerate,
collide, fuse and split them (the latter can happen spontaneously or after a
collision). Fusing or splitting particles doesn't always lead to only one rest
particle, hence the pointer (array). Destroying particles only happens in 
pairs. We may have gone slighty overboard on the "keep it small/simple" aspect
but we hope this helps illustrate our understanding of classes in a fun way.

Implementing this class would require a bunch of stuff going on under the
hood, like the field theory equations that actually govern how particles
couple with forces. These could be put inside the private member function
section (that comes after the public ones). We have left them out for clarity.
